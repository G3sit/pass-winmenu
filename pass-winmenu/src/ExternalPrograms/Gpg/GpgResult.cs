using System;
using System.Collections.Generic;
using System.Linq;

namespace PassWinmenu.ExternalPrograms.Gpg
{
	internal class GpgResult
	{
		public StatusMessage[] StatusMessages { get; }
		public string[] StderrMessages { get; }
		public string RawStdout { get; }
		// Messages isn't entirely the right term here, but it is meant to indicate
		// that this field should only be used when splitting on messages generated by GPG.
		// When printing decrypted content to standard output, that content may not be
		// CRLF-delimited, and the raw content should be used intead.
		public string[] StdoutMessages { get; }
		public int ExitCode { get; }

		private IEnumerable<GpgStatusCode> StatusCodes => StatusMessages.Select(m => m.StatusCode);

		public GpgResult(int exitCode, string stdout, IEnumerable<StatusMessage> statusMessages, IEnumerable<string> stderrMessages)
		{
			ExitCode = exitCode;
			RawStdout = stdout;
			StdoutMessages = stdout?.Split(new[] { "\r\n" }, StringSplitOptions.None) ?? Array.Empty<string>();
			StatusMessages = statusMessages.ToArray();
			StderrMessages = stderrMessages.ToArray();
		}

		public void GenerateError()
		{
			throw new GpgException($"GPG returned the following errors: \n{string.Join("\n", StderrMessages.Select(m => "    " + m))}");
		}

		public void EnsureNonZeroExitCode()
		{
			if (ExitCode != 0)
			{
				throw new GpgException($"GPG exited with status {ExitCode}\n\nOutput:\n{string.Join("\n", StderrMessages)}");
			}
		}

		public bool HasStatusCodes(params GpgStatusCode[] required)
		{
			return required.All(StatusCodes.Contains);
		}
	}
}
